---
layout: vimdoc
helpname: 'channel'
---
<div id='vimCodeElement'>
<span class="MissingTag">channel.txt</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;For&nbsp;<span class="Identifier">Vim バージョン 8.0.</span>&nbsp;&nbsp;Last change: 2016 Dec 02<br>
<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="Identifier">VIMリファレンスマニュアル&nbsp;&nbsp;&nbsp;&nbsp;by Bram Moolenaar</span><br>
<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;プロセス間通信&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="MissingTag">channel</span><br>
<br>
Vimは別のプロセスと通信するのにチャンネルを用います。<br>
チャンネルはソケットまたはパイプを用います。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="MissingTag">socket-interface</span><br>
ジョブはプロセスを開始し、プロセスと通信するために使用できます。<br>
Netbeansインターフェイスもチャンネルを使っています。<span class="MissingTag">netbeans</span><br>
<br>
1. 概要&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="MissingTag">job-channel-overview</span><br>
2. チャンネルデモ&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="MissingTag">channel-demo</span><br>
3. チャンネルを開く&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="MissingTag">channel-open</span><br>
4. JSON、JSチャンネルを使う&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="MissingTag">channel-use</span><br>
5. チャンネルコマンド&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="MissingTag">channel-commands</span><br>
6. RAW、NLチャンネルをつかう&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="MissingTag">channel-raw</span><br>
7. その他のチャンネル機能&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="MissingTag">channel-more</span><br>
8. チャンネルでジョブを開始する&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="MissingTag">job-start</span><br>
9. チャンネルなしでジョブを開始する&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="MissingTag">job-start-nochannel</span><br>
10. ジョブオプション&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="MissingTag">job-options</span><br>
11. ジョブを制御する&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="MissingTag">job-control</span><br>
<br>
<span class="Special">{Vi にはこれらの機能はありません}</span><br>
<span class="Special">{Vim が&nbsp;</span><span class="MissingTag">+channel</span><span class="Special">&nbsp;機能付きでコンパイルされたときのみ有効}</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="Comment">has('channel')</span>&nbsp;でこれを確認できる<br>
<span class="Special">{Vim が&nbsp;</span><span class="MissingTag">+job</span><span class="Special">&nbsp;機能付きでコンパイルされたときのみ有効}</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="Comment">has('job')</span>&nbsp;でこれを確認できる<br>
<br>
<span class="PreProc">==============================================================================</span><br>
1. 概要&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="MissingTag">job-channel-overview</span><br>
<br>
主に4種類のジョブがあります:<br>
1. いくつかの Vim インスタンスを扱うデーモン。Vim はソケットで接続します。<br>
2. 1つの Vim インスタンスを1つのジョブが非同期に処理する。ソケットまたはパイプ<br>
&nbsp;&nbsp; を使用します。<br>
3. 短時間、非同期で仕事をするジョブ。ソケットまたはパイプを使用します。<br>
4. フィルタを同期して実行する。パイプを使用します。<br>
<br>
ソケットを使用する場合&nbsp;<span class="MissingTag">job-start</span>、<span class="MissingTag">job-start-nochannel</span>、および<br>
<span class="MissingTag">channel-open</span>&nbsp;参照。2と3の場合は、パイプを使用する1つ以上のジョブです<br>
(<span class="MissingTag">job-start</span>&nbsp;参照)。<br>
4の場合、&quot;:<span class="Special">{range}</span>!cmd&quot; コマンドを使用します(<span class="MissingTag">filter</span>&nbsp;参照)。<br>
<br>
ソケットとパイプ上でこれらのプロトコルを利用できます:<br>
RAW&nbsp;&nbsp;&nbsp;&nbsp; 何も知られていない、Vim はメッセージの終わりを知らせない。<br>
NL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;すべてのメッセージは NL (改行)文字で終わります。<br>
JSON&nbsp;&nbsp;&nbsp;&nbsp;JSON エンコーディング&nbsp;<span class="MissingTag">json_encode()</span><br>
JS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JavaScript スタイルの JSON 風のエンコーディング&nbsp;<span class="MissingTag">js_encode()</span><br>
<br>
共通の組み合わせ:<br>
- NL モードでパイプを介して接続されたジョブを使用します。例えば、スタイルチェッ<br>
&nbsp;&nbsp;カーを実行し、エラーと警告を受け取ります。<br>
- デーモンを使用して、JSON モードでソケットに接続します。例えば、データベース<br>
&nbsp;&nbsp;内の相互参照を参照します。<br>
<br>
<span class="PreProc">==============================================================================</span><br>
2. チャンネルデモ&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="MissingTag">channel-demo</span>&nbsp;<span class="MissingTag">demoserver.py</span><br>
<br>
デモにはPythonが必要です。デモプログラムは次の場所にあります。<br>
$VIMRUNTIME/tools/demoserver.py<br>
それをあるターミナルで実行しましょう。そのターミナルをT1と呼びます。<br>
<br>
次に別のターミナルでVimを実行します。そして以下のコマンドでサーバーに接続しま<br>
す:<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let channel = ch_open('localhost:8765')</div>
<br>
T1の中に次のように表示されます:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="PreProc">=== socket opened ===</span><br>
<br>
ついにサーバーにメッセージを送信できます:<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo ch_evalexpr(channel, 'hello!')</div>
<br>
このメッセージはT1で受信され、Vimには応答が送り返されます。<br>
T1ではVimが送った生のメッセージを確認できます:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="PreProc">[1,&quot;hello!&quot;]</span><br>
そしてレスポンスはこうなります:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="PreProc">[1,&quot;got it&quot;]</span><br>
この数値はメッセージを送るたびに増加していきます。<br>
<br>
サーバーはVimにコマンドを送信できます。T1において、次のように正確に(引用符を含<br>
めて文字通りに)タイプしてください:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="PreProc">[&quot;ex&quot;,&quot;echo 'hi there'&quot;]</span><br>
するとそのメッセージがVimに表示されます。カーソルを1単語先に移動することができ<br>
ます:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="PreProc">[&quot;normal&quot;,&quot;w&quot;]</span><br>
<br>
非同期通信を取り扱うためにはコールバック(以下ハンドラー)が必要です:<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;func MyHandler(channel, msg)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo &quot;from the handler: &quot; . a:msg<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;endfunc<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;call ch_sendexpr(channel, 'hello!', {'callback': &quot;MyHandler&quot;})</div>
Vim は応答を待つことはありません。これで、サーバーは応答を後で送信し、<br>
MyHandler が呼び出されます。<br>
<br>
sendを呼ぶたびに毎回コールバックを指定する代わりに、チャンネルを開く際に指定す<br>
ることもできます:<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;call ch_close(channel)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let channel = ch_open('localhost:8765', {'callback': &quot;MyHandler&quot;})<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;call ch_sendexpr(channel, 'hello!')</div>
<br>
チャンネルを試してみると、何が起こっているのかを知ることができます。あなたは<br>
Vim にログファイルに行を書くよう指示することができます:<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;call ch_logfile('channellog', 'w')</div>
<span class="MissingTag">ch_logfile()</span>&nbsp;参照.<br>
<br>
<span class="PreProc">==============================================================================</span><br>
3. チャンネルを開く&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="MissingTag">channel-open</span><br>
<br>
チャンネルを開くには次のようにします:<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;let channel = ch_open({address} [, {options}])<br>
&nbsp;&nbsp;&nbsp;&nbsp;if ch_status(channel) == &quot;open&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot; use the channel</div>
<br>
<span class="MissingTag">ch_status()</span>&nbsp;を使用して、チャンネルを開くことができたかどうかを確認します。<br>
<br>
<span class="Special">{address}</span>&nbsp;は &quot;ホスト名:ポート番号&quot; の形式です。例:&quot;localhost:8765&quot;<br>
<br>
<span class="Special">{options}</span>&nbsp;はオプションのエントリを持つ辞書です:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="MissingTag">channel-open-options</span><br>
<br>
&quot;mode&quot; でモード(通信フォーマット)を指定します:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="MissingTag">channel-mode</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;json&quot; - JSONを使う(詳しくは下記を参照。もっとも使いやすい方法。既定)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;js&quot;&nbsp;&nbsp; - JS(JavaScript) エンコーディングを使用し、JSON よりも効率的。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;nl&quot;&nbsp;&nbsp; - NL 文字で終わるメッセージを使う<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;raw&quot;&nbsp;&nbsp;- rawメッセージを使う<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="MissingTag">channel-callback</span>&nbsp;<span class="MissingTag">E921</span><br>
&quot;callback&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;メッセージ受信時に他のハンドラーで扱われない時に呼ばれます。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;これはチャンネルのハンドルと、受信したメッセージの2つの引数を<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;取ります。例:<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;func Handle(channel, msg)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo '受信した: ' . a:msg<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;endfunc<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let channel = ch_open(&quot;localhost:8765&quot;, {&quot;callback&quot;: &quot;Handle&quot;})</div>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;mode&quot; が &quot;json&quot;, &quot;js&quot; の時には、&quot;msg&quot; 引数は受信したメッセー<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ジの本文で、Vimの型に変換されています。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;mode&quot; が &quot;nl&quot; の時には、&quot;msg&quot; 引数は NL を除く1つのメッセージ<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;です。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;mode&quot; が &quot;raw&quot; の時には、&quot;msg&quot; 引数はメッセージ全体を格納し<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;た文字列です。<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;すべてのコールバック:&nbsp;<span class="MissingTag">function()</span>&nbsp;を使用して、引数および/また<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;は辞書にバインドします。または、&quot;dict.function&quot; という形式を使<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用して辞書をバインドします。<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;コールバックは、通常、Vim がユーザーが文字を入力するのを待って<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;いるとき、「安全な」瞬間にのみ呼び出されます。Vim はマルチス<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;レッドを使用しません。<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="MissingTag">close_cb</span><br>
&quot;close_cb&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="MissingTag">ch_close()</span>&nbsp;を呼び出す以外に、チャンネルが閉じられたときに呼<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;び出される関数。このように定義する必要があります:<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;func MyCloseHandler(channel)</div>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vim は close_cb を呼び出す前にデータを処理するコールバックを呼<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;び出します。したがって、この関数が呼び出されると、それ以上の<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;データはコールバックに渡されません。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="MissingTag">channel-drop</span><br>
&quot;drop&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;メッセージをいつドロップするかを指定します:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;auto&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;メッセージを処理するコールバックがない場合。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;close_cb&quot; もこのために考慮されます。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;never&quot;&nbsp;&nbsp;&nbsp;&nbsp; すべてのメッセージが保存されます。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="MissingTag">waittime</span><br>
&quot;waittime&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接続がミリ秒単位で待機する時間。負の数は永遠に待ちます。<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;デフォルトはゼロで、待機しません。これは、ローカルサーバーがす<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;でに実行されている場合に便利です。Unix Vim では実際には1msのタ<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;イムアウトが使われます。多くのシステムではそれが必要なためで<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;す。リモートサーバーには大きな値を使用してください。例: 少なく<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;とも10msec。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="MissingTag">channel-timeout</span><br>
&quot;timeout&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ブロッキング時にリクエストを待つ時間(例:&nbsp;<span class="MissingTag">ch_evalexpr()</span>&nbsp;を使用<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;するとき。ミリ秒単位。デフォルトは2000(2秒)です。<br>
<br>
&quot;mode&quot; が &quot;json&quot; か &quot;js&quot; の時には &quot;callback&quot; はオプションです。これを省略した<br>
場合、メッセージを1つ受信するにはメッセージを1つ送信する必要があります。<br>
<br>
チャンネルオプションを開いた後に変更するには、<span class="MissingTag">ch_setoptions()</span>&nbsp;を使用します。<br>
引数は&nbsp;<span class="MissingTag">ch_open()</span>&nbsp;に渡されるものと似ていますが、&quot;waittime&quot; は与えられません。<br>
これはチャンネルを開く場合にのみ適用されるためです。<br>
<br>
例えば、ハンドラーは後から追加したり、変更したりできます:<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;call ch_setoptions(channel, {'callback': callback})</div>
&quot;callback&quot; が空の場合 (一度も指定しないか、空文字列を指定した場合) ハンドラー<br>
は削除されます。<br>
<br>
コールバックが呼び出された後、Vim は画面を更新し、カーソルをそれが属する場所に<br>
戻します。コールバックは&nbsp;<span class="Comment">:redraw</span>&nbsp;を行う必要はありません。<br>
<br>
タイムアウトは次のように変更できます:<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;call ch_setoptions(channel, {'timeout': msec})</div>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="MissingTag">channel-close</span>&nbsp;<span class="MissingTag">E906</span><br>
チャンネルを使い終わったら、以下のように切断してください:<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;call ch_close(channel)</div>
ソケットが使用されていると、両方向のソケットが閉じられます。パイプが使用されて<br>
いると(stdin/stdout/stderr)、それらはすべて閉じられます。これはあなたが望むもの<br>
ではないかもしれません!&nbsp;<span class="MissingTag">job_stop()</span>&nbsp;でジョブを停止する方が良いかもしれません。<br>
すべての先読みは破棄され、コールバックは呼び出されなくなります。<br>
<br>
チャンネルは3つの段階で閉じられることに注意してください:<br>
&nbsp;&nbsp;- I/O が終了し、ログメッセージ: &quot;Closing channel&quot; が表示されます。呼び出すた<br>
&nbsp;&nbsp;&nbsp;&nbsp;めの読み込みまたはコールバックのキューに入れられたメッセージがまだ残ってい<br>
&nbsp;&nbsp;&nbsp;&nbsp;る可能性があります。<br>
&nbsp;&nbsp;- 先読みがクリアされ、ログメッセージ: &quot;Clearing channel&quot; が表示されます。変<br>
&nbsp;&nbsp;&nbsp;&nbsp;数によっては引き続きチャンネルを参照することがあります。<br>
&nbsp;&nbsp;- チャンネルが解放され、ログメッセージ： &quot;Freeing channel&quot; が表示されます。<br>
<br>
チャンネルを開くことができない場合、エラーメッセージが表示されます。MS-Windows<br>
と Unix には違いがあります: Unix では、ポートが存在しないとき、<span class="MissingTag">ch_open()</span>&nbsp;は<br>
すぐに失敗します。MS-Windows では &quot;waittime&quot; が適用されます。<br>
<span class="MissingTag">E898</span>&nbsp;<span class="MissingTag">E901</span>&nbsp;<span class="MissingTag">E902</span><br>
<br>
チャンネルを読み書きする際にエラーが発生した場合、チャンネルは閉じられます。<br>
<span class="MissingTag">E630</span>&nbsp;<span class="MissingTag">E631</span><br>
<br>
<span class="PreProc">==============================================================================</span><br>
4. JSON、JSチャンネルを使う&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="MissingTag">channel-use</span><br>
<br>
&quot;mode&quot; が JSON の場合は、以下のようにメッセージを同期的に送信できます:<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;let response = ch_evalexpr(channel, {expr})</div>
これは通信相手から応答があるまで待ち合わせます。<br>
<br>
mode が JS の場合は、メッセージが JavaScript エンコーディングを使用する点を除<br>
いて、これは同じです。その違いについては、<span class="MissingTag">js_encode()</span>参照。<br>
<br>
応答を処理せずにメッセージを送信する、またはチャンネルコールバックに応答を処理<br>
させるには:<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;call ch_sendexpr(channel, {expr})</div>
<br>
メッセージを送信し、応答を特別な関数で非同期的に処理する場合には、このようにし<br>
ます:<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;call ch_sendexpr(channel, {expr}, {'callback': Handler})</div>
<br>
Vim は、メッセージIDを使用して要求との応答を照合します。応答が受信されると、<br>
コールバックが呼び出されます。同じIDを持つさらなる応答は無視されます。あなたの<br>
サーバーが複数の応答を返信する場合、IDゼロで送信する必要があります。それらは<br>
チャンネルコールバックに渡されます。<br>
<br>
<span class="Special">{expr}</span>&nbsp;は JSON に変換され、配列で包まれます。<span class="Special">{expr}</span>&nbsp;として文字列 &quot;hello&quot; を送<br>
信した場合に、通信相手が受け取るメッセージの例は次のようになります:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="PreProc">[12,&quot;hello&quot;]</span><br>
<br>
送信されるJSONのフォーマットはこのようになっています:<br>
&nbsp;&nbsp;&nbsp;&nbsp;[<span class="Special">{number}</span>,<span class="Special">{expr}</span>]<br>
<br>
<span class="Special">{number}</span>&nbsp;には毎回異なる値が入ります。これは応答があるならば、必ず使われます:<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;[<span class="Special">{number}</span>,<span class="Special">{response}</span>]<br>
<br>
このようにして、受信したメッセージがどの送信メッセージに対応するかを知ることが<br>
でき、正しいハンドラーを呼び出すことができます。これによって応答メッセージの到<br>
着順序を気にしなくても良くなります。<br>
<br>
改行文字が JSON テキストを終了しています。これは、読み込まれたテキストを区切る<br>
ために使用できます。例えばPythonでは:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;splitidx = read_text.find('\n')<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;message = read_text[:splitidx]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rest = read_text[splitidx + 1:]<br>
<br>
送信側はかならず有効なJSONをVimへ送らなければなりません。VimはJSONとして解釈す<br>
ることで、受信メッセージの終端をチェックします。終端を受信することが、<br>
メッセージを受理する唯一の方法です。A newline after the message is optional.<br>
<br>
サーバープロセスがVimからのメッセージを受信すること無く、メッセージを送信する<br>
には、数値に 0 を使う必要があります。<br>
&nbsp;&nbsp;&nbsp;&nbsp;[0,<span class="Special">{response}</span>]<br>
<br>
するとチャンネルのハンドラーが&nbsp;<span class="Special">{response}</span>&nbsp;をVimの方に変換したものを受け取るで<br>
しょう。チャンネルにハンドラーが関連付けられていない場合には、メッセージは破棄<br>
されます。<br>
<br>
JSON または JS チャンネルで&nbsp;<span class="MissingTag">ch_sendraw()</span>&nbsp;および&nbsp;<span class="MissingTag">ch_evalraw()</span>&nbsp;を使用するこ<br>
ともできます。その場合呼び出し元は、正しくエンコードとデコードを行う完全な責任<br>
があります。<br>
<br>
<span class="PreProc">==============================================================================</span><br>
5. チャンネルコマンド&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="MissingTag">channel-commands</span><br>
<br>
JSON チャンネルを使用すると、サーバープロセス側はVimへコマンドを送信できます。<br>
そのコマンドはチャンネルのハンドラーを介さずに、Vimの内部で実行されます。<br>
<br>
実行可能なコマンドは以下のとおりです:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="MissingTag">E903</span>&nbsp;<span class="MissingTag">E904</span>&nbsp;<span class="MissingTag">E905</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;[&quot;redraw&quot;,&nbsp;<span class="Special">{forced}</span>]<br>
&nbsp;&nbsp;&nbsp;&nbsp;[&quot;ex&quot;,&nbsp;&nbsp;&nbsp;&nbsp; {Ex コマンド}]<br>
&nbsp;&nbsp;&nbsp;&nbsp;[&quot;normal&quot;, {ノーマルモードコマンド}]<br>
&nbsp;&nbsp;&nbsp;&nbsp;[&quot;eval&quot;,&nbsp;&nbsp; {式}, {数値}]<br>
&nbsp;&nbsp;&nbsp;&nbsp;[&quot;expr&quot;,&nbsp;&nbsp; {式}]<br>
&nbsp;&nbsp;&nbsp;&nbsp;[&quot;call&quot;,&nbsp;&nbsp; {関数名}, {引数リスト}, {数値}]<br>
&nbsp;&nbsp;&nbsp;&nbsp;[&quot;call&quot;,&nbsp;&nbsp; {関数名}, {引数リスト}]<br>
<br>
これらを使うときは、これらのコマンドが何をするかに十分気をつけてください!<br>
ユーザーが何をしているかによっては容易に干渉してしまいます。トラブルを避けるに<br>
は&nbsp;<span class="MissingTag">mode()</span>&nbsp;を使い、エディタが期待した状態にあるかチェックしてください。例え<br>
ば、コマンド実行ではなくテキストとして入力させたい文字列を送るには、以下のよう<br>
にします:<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="PreProc">[&quot;ex&quot;,&quot;if mode() == 'i' | call feedkeys('ClassName') | endif&quot;]</span><br>
<br>
これらのコマンドのエラーは、表示が乱れないようにするため、通常は報告されませ<br>
ん。表示したい場合は、<span class="MissingTag">'verbose'</span>&nbsp;オプションを3以上に設定してください。<br>
<br>
<br>
<span class="PreProc">コマンド &quot;redraw&quot;</span><br>
<br>
他のコマンドは画面を更新しないので、カーソルを動かさずに一連のコマンドを送るこ<br>
とができます。変更されたテキストを表示し、それが属する場所にカーソルを表示する<br>
には、&quot;redraw&quot; コマンドで終了する必要があります。<br>
<br>
引数は通常は空の文字列です:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="PreProc">[&quot;redraw&quot;, &quot;&quot;]</span><br>
最初に画面をクリアするには &quot;force&quot; を渡してください:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="PreProc">[&quot;redraw&quot;, &quot;force&quot;]</span><br>
<br>
<br>
<span class="PreProc">コマンド &quot;ex&quot;</span><br>
<br>
&quot;ex&quot; コマンドは Ex コマンドを実行します。完了やエラーの応答はありませ<br>
ん。<span class="MissingTag">autoload</span>&nbsp;スクリプトの中の関数を使えます:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&quot;ex&quot;,&quot;call myscript#MyFunc(arg)&quot;]<br>
<br>
<br>
&quot;call&nbsp;<span class="MissingTag">feedkeys()</span>&quot; を使用してキーシーケンスを挿入することもできます。<br>
<br>
エラーが発生すると、チャンネルログにメッセージが書き込まれ、存在する場合は<br>
v:errmsg にエラーが設定されます。<br>
<br>
<br>
<span class="PreProc">コマンド &quot;normal&quot;</span><br>
<br>
&quot;normal&quot; コマンドは &quot;:normal!&quot; のように実行され、コマンドはマップされません。<br>
カーソルの下の折畳を開く例:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&quot;normal&quot; &quot;zO&quot;]<br>
<br>
<br>
<span class="PreProc">コマンド &quot;expr&quot; (応答あり)</span><br>
<br>
&quot;expr&quot; コマンドは、式の結果を得るために使うことができます。たとえば、現在のバッ<br>
ファ内の行数を取得するには、次のようにします:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="PreProc">[&quot;expr&quot;,&quot;line('$')&quot;, -2]</span><br>
<br>
式の結果を返します:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="PreProc">[-2, &quot;last line&quot;]</span><br>
形式は次のとおりです:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[<span class="Special">{number}</span>,&nbsp;<span class="Special">{result}</span>]<br>
<br>
<span class="Special">{number}</span>&nbsp;は、リクエストに指定したのと同じものです。Vim が送信するメッセージと<br>
の混乱を避けるには、負の数を使用します。リクエストとレスポンスを一致させるに<br>
は、リクエストごとに異なる番号を使用します。<br>
<br>
<span class="Special">{result}</span>&nbsp;は評価の結果であり、JSON エンコードされています。評価が失敗したり、結<br>
果を JSON でエンコードできない場合は、文字列 &quot;ERROR&quot; となります。<br>
<br>
<br>
<span class="PreProc">コマンド &quot;expr&quot; (応答なし)</span><br>
<br>
このコマンドは上記の &quot;expr&quot; に近いのですが、応答を返信しません。<br>
例:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="PreProc">[&quot;expr&quot;,&quot;setline('$', ['one', 'two', 'three'])&quot;]</span><br>
リクエストに第3引数はありません。<br>
<br>
<br>
<span class="PreProc">コマンド &quot;call&quot;</span><br>
<br>
これは &quot;expr&quot; に似ていますが、式全体を文字列として渡す代わりに、関数の名前と引<br>
数のリストを渡します。これは、引数の文字列への変換を避け、エスケープして連結し<br>
ます。例:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="PreProc">[&quot;call&quot;, &quot;line&quot;, [&quot;$&quot;], -2]</span><br>
<br>
応答が送信されない場合は、第4引数を省いてください:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="PreProc">[&quot;call&quot;, &quot;setline&quot;, [&quot;$&quot;, [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;]]]</span><br>
<br>
<span class="PreProc">==============================================================================</span><br>
6. RAW、NL チャンネルを使う&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="MissingTag">channel-raw</span><br>
<br>
モードがRAWかNLの場合には、以下のようにしてメッセージを送信します:<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;let response = ch_evalraw(channel, {string})</div>
<br>
<span class="Special">{string}</span>&nbsp;はそのまま送信されます。受信した応答メッセージは直ちにチャンネルから<br>
読み込み可能になります。この時、Vimにはメッセージの終了をどう判断するかがわか<br>
りませんから、あなた自身が面倒を見る必要があります。タイムアウトは、最初のバイ<br>
トを読み取るために適用され、その後は何も待つことはありません。<br>
<br>
mode が &quot;nl&quot; の場合、同様の方法でメッセージを送信できます。あなたは各メッセー<br>
ジの後に NL に入れなければなりません。したがって、一度に NL で終わる複数のメッ<br>
セージを送信することもできます。応答は最初の NL までのテキストとなります。これ<br>
は空のレスポンスの NL だけでもかまいません。チャンネルタイムアウトの前に NL が<br>
読み取られなかった場合、空の文字列が返されます。<br>
<br>
<br>
応答を必要としないメッセージを送信するには以下のようにします:<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;call ch_sendraw(channel, {string})</div>
プロセス<span class="Special">{訳注:サーバーのこと}</span>はレスポンスを返し、チャンネルのハンドラーに渡さ<br>
れます。<br>
<br>
メッセージを送信し、レスポンスを特定の関数で非同期的に取り扱うには以下のように<br>
します:<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;call ch_sendraw(channel, {string}, {'callback': 'MyHandler'})</div>
<br>
この&nbsp;<span class="Special">{string}</span>&nbsp;はJSONにもできます。その場合、<span class="MissingTag">json_encode()</span>&nbsp;でそれを作成し<br>
<span class="MissingTag">json_decode()</span>&nbsp;で受信したJSONメッセージを取り扱います。<br>
<br>
生のチャンネルで&nbsp;<span class="MissingTag">ch_evalexpr()</span>&nbsp;または&nbsp;<span class="MissingTag">ch_sendexpr()</span>&nbsp;を使用することはできま<br>
せん。<br>
<br>
Vim の文字列に NUL バイトを含めることはできません。NUL バイトを送受信するには、<br>
バッファから読み書きしてください。<span class="MissingTag">in_io-buffer</span>&nbsp;と&nbsp;<span class="MissingTag">out_io-buffer</span>&nbsp;参照。<br>
<br>
<span class="PreProc">==============================================================================</span><br>
7. その他のチャンネル機能&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="MissingTag">channel-more</span><br>
<br>
チャンネルのステータスを取得するには、ch_status(channel)を使用します。ありうる<br>
結果は次のとおりです:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;fail&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;チャンネルを開くことができませんでした。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;open&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;チャンネルを使用することができます。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;buffered&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;チャンネルは閉じられましたが読み込むデータがあります。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;closed&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;チャンネルが閉じられました。<br>
<br>
チャンネルに関連付けられたジョブを取得するには: ch_getjob(channel)<br>
<br>
チャンネルから1つのメッセージを読むには:<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let output = ch_read(channel)</div>
これは、チャンネルのタイムアウトを使用します。タイムアウトなしで読むには、利用<br>
可能なメッセージを取得するだけです:<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let output = ch_read(channel, {'timeout': 0})</div>
メッセージが利用できなかった場合、結果は JSON またはJSモードのチャンネルでは<br>
v:none、RAW または NL チャンネルでは空の文字列です。<span class="MissingTag">ch_canread()</span>&nbsp;を使用して、<br>
何かがあるかどうかを調べることができます。<br>
<br>
コールバックメッセージがない場合、メッセージは破棄されます。これを回避するに<br>
は、チャンネルにコールバックを追加します。<br>
<br>
使用可能なRAWチャンネルからすべての出力を読み込むには:<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let output = ch_readraw(channel)</div>
エラー出力を読むには:<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let output = ch_readraw(channel, {&quot;part&quot;: &quot;err&quot;})</div>
<br>
ch_read() と ch_readraw() はチャンネルタイムアウトを使用します。その時間内に何<br>
も読み込めない場合、空の文字列が返されます。別のタイムアウトをミリ秒で指定する<br>
には、&quot;timeout&quot; オプションを使用します:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="PreProc">{&quot;timeout&quot;: 123}</span><br>
エラー出力から読み込むには、&quot;part&quot; オプションを使用します:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="PreProc">{&quot;part&quot;: &quot;err&quot;}</span><br>
特定の ID を持つメッセージを JS または JSON チャンネルで読み取るには:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="PreProc">{&quot;id&quot;: 99}</span><br>
ID が指定されていないか、または ID が-1の場合、最初のメッセージが返されます。<br>
これは、このメッセージを待っているコールバックをすべて無効にします。<br>
<br>
RAW チャンネルの場合、Vim はメッセージの終わりを知らないので、利用可能なものを<br>
返します。<br>
NL チャンネルの場合、これは1つのメッセージを返します。<br>
JS または JSON チャンネルの場合、これは1つのデコードされたメッセージを返しま<br>
す。<br>
これには、任意のシーケンス番号が含まれます。<br>
<br>
<span class="PreProc">==============================================================================</span><br>
8. チャンネルでジョブを開始する&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="MissingTag">job-start</span>&nbsp;<span class="MissingTag">job</span><br>
<br>
<br>
ジョブを開始し、stdin/stdout/stderr のチャンネルを開くには:<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;let job = job_start(command, {options})</div>
<br>
チャンネルを得るには:<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;let channel = job_getchannel(job)</div>
<br>
チャンネルは NL モードを使用します。別のモードが必要な場合は、<span class="Special">{options}</span>&nbsp;でこれ<br>
を指定することをお勧めします。後でモードを変更すると、一部のテキストがすでに受<br>
信され、正しく解析されていない可能性があります。<br>
<br>
コマンドが処理したい出力行を生成する場合は、stdout のハンドラを指定します:<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;let job = job_start(command, {&quot;out_cb&quot;: &quot;MyHandler&quot;})</div>
この関数は、チャンネルとメッセージで呼び出されます。あなたはこれをこのように定<br>
義します:<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;func MyHandler(channel, msg)</div>
<br>
ハンドラがなければ、<span class="MissingTag">ch_read()</span>&nbsp;または&nbsp;<span class="MissingTag">ch_readraw()</span>&nbsp;で出力を読み取る必要があ<br>
ります。クローズコールバックでこれを行うことができます。<span class="MissingTag">read-in-close-cb</span>&nbsp;参<br>
照。<br>
<br>
出力を読み取る前にジョブが終了すると、出力が失われる可能性があることに注意して<br>
ください。これはシステムによって異なります(Unix 上では、パイプの書き込み終了を<br>
閉じると EOF が得られます)。これを避けるには、ジョブが終了する前にそれをしばら<br>
くスリープさせること。<br>
<br>
&quot;out_cb&quot; に定義されたハンドラは stderr を受け取りません。もし個別に扱いたい場<br>
合は、&quot;err_cb&quot; ハンドラを追加します:<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;let job = job_start(command, {&quot;out_cb&quot;: &quot;MyHandler&quot;,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;err_cb&quot;: &quot;ErrHandler&quot;})</div>
<br>
1つのハンドラで stderr と stdout の両方を処理する場合は、&quot;callback&quot; オプション<br>
を使用します:<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;let job = job_start(command, {&quot;callback&quot;: &quot;MyHandler&quot;})&nbsp;</div>
<br>
ch_evalraw() でコマンドにメッセージを送ることができます。チャンネルが JSON ま<br>
たは JS モードの場合、ch_evalexpr() を使用できます。<br>
<br>
使用できるオプションがいくつかあります。<span class="MissingTag">job-options</span>&nbsp;参照。<br>
例えば、ジョブを開始し、その出力をバッファ &quot;dummy&quot; に書き込むには:<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let logjob = job_start(&quot;tail -f /tmp/log&quot;,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \ {'out_io': 'buffer', 'out_name': 'dummy'})<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sbuf dummy</div>
<br>
<br>
<span class="PreProc">バッファからのジョブ入力</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="MissingTag">in_io-buffer</span><br>
バッファから読み取るジョブを実行するには:<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let job = job_start({command},<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\ {'in_io': 'buffer', 'in_name': 'mybuffer'})</div>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="MissingTag">E915</span>&nbsp;<span class="MissingTag">E918</span><br>
バッファは、<span class="MissingTag">bufnr()</span>&nbsp;と同様の名前で見つけられます。バッファは、job_start()<br>
が呼び出されたときに存在し、ロードされていなければなりません。<br>
<br>
デフォルトでは、これはバッファ全体を読み込みます。これは &quot;in_top&quot; と &quot;in_bot&quot;<br>
オプションで変更できます。<br>
<br>
特殊モードは、in_top が0に設定され、in_bot が設定されていない場合です。バッファ<br>
に行が追加されるたびに、最後の1行がジョブ stdin に送信されます。これにより、<br>
最後の行を編集し、Enter を押したときに送信することができます。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="MissingTag">channel-close-in</span><br>
特殊モードを使用しないときは、最後の行が書き込まれた後にパイプまたはソケットが<br>
閉じられます。これは、入力が終了した読み取り終了を知らせます。<span class="MissingTag">ch_close_in()</span><br>
を使用すると、より早く終了することもできます。<br>
<br>
テキストの NUL バイトはジョブに渡されます(内部では Vim はこれらを NL バイトと<br>
して格納します)。<br>
<br>
<br>
<span class="PreProc">クローズコールバックでジョブ出力を読み込む</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="MissingTag">read-in-close-cb</span><br>
ジョブに時間がかかり、中間結果が必要ない場合は、クローズコールバックを追加して<br>
そこの出力を読み取ることができます:<br>
<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;func! CloseHandler(channel)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while ch_status(a:channel, {'part': 'out'}) == 'buffered'<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echomsg ch_read(a:channel)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;endwhile<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;endfunc<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let job = job_start(command, {'close_cb': 'CloseHandler'})</div>
<br>
あなたは &quot;echomsg&quot; よりも役に立つ何かをしたいでしょう。<br>
<br>
<span class="PreProc">==============================================================================</span><br>
9. チャンネルなしでジョブを開始する&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="MissingTag">job-start-nochannel</span><br>
<br>
チャンネルを作成せずに別のプロセスを開始するには:<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;let job = job_start(command,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\ {&quot;in_io&quot;: &quot;null&quot;, &quot;out_io&quot;: &quot;null&quot;, &quot;err_io&quot;: &quot;null&quot;})</div>
<br>
これはバックグラウンドで&nbsp;<span class="Special">{command}</span>&nbsp;を開始し、Vim はそれが完了するのを待ちませ<br>
ん。<br>
<br>
Vim が stdin、stdout、stderr のいずれも接続されていないと判断すると、チャンネ<br>
ルは作成されません。コマンドが停止するのを避けるために、リダイレクションをコマ<br>
ンドに含めることがよくあります。<br>
<br>
使用できるオプションがいくつかあります。<span class="MissingTag">job-options</span>&nbsp;参照。<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="MissingTag">job-start-if-needed</span><br>
アドレスへの接続が動作しない時にのみジョブを開始するには、次のような操作を行い<br>
ます:<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let channel = ch_open(address, {&quot;waittime&quot;: 0})<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ch_status(channel) == &quot;fail&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let job = job_start(command)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let channel = ch_open(address, {&quot;waittime&quot;: 1000})<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;endif</div>
<br>
ch_open() の待ち時間は、ポートを利用可能にするためにジョブに1秒を与えることに<br>
注意してください。<br>
<br>
<span class="PreProc">==============================================================================</span><br>
10. ジョブオプション&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="MissingTag">job-options</span><br>
<br>
job_start() の&nbsp;<span class="Special">{options}</span>&nbsp;引数は辞書です。すべての入力はオプションです。<br>
job_setoptions(job,&nbsp;<span class="Special">{options}</span>) を使用して、ジョブの開始後にいくつかのオプショ<br>
ンを使用できます。ch_setoptions(channel,&nbsp;<span class="Special">{options}</span>) を使用して、ジョブに関連す<br>
るチャンネルで多くのオプションを使用できます。<span class="MissingTag">job_setoptions()</span>&nbsp;および<br>
<span class="MissingTag">ch_setoptions()</span>&nbsp;参照。<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="MissingTag">in_mode</span>&nbsp;<span class="MissingTag">out_mode</span>&nbsp;<span class="MissingTag">err_mode</span><br>
&quot;in_mode&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stdin 用のモード、パイプを使用している場合にのみ。<br>
&quot;out_mode&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stdout 用のモード、パイプを使用している場合にのみ。<br>
&quot;err_mode&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stderr 用のモード、パイプを使用している場合にのみ。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;値については、<span class="MissingTag">channel-mode</span>&nbsp;参照。<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="Todo">Note</span>: &quot;mode&quot; を設定すると、パーツ固有のモードが上書き<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;されます。したがって、最初に &quot;mode&quot; を、後でパーツ固<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有のモードを設定します。<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="Todo">Note</span>: ファイルやバッファに書き込むときやバッファから読<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;み込むときは、NL モードがデフォルトで使用されます。<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="MissingTag">job-callback</span><br>
&quot;callback&quot;: handler&nbsp;&nbsp;&nbsp;&nbsp; チャンネルの任意の部分で何かを読むためのコールバック。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="MissingTag">job-out_cb</span>&nbsp;<span class="MissingTag">out_cb</span><br>
&quot;out_cb&quot;: handler&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stdout で読み込むべきものがあるときのコールバック。チャ<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ンネルがパイプを使用している場合のみ。&quot;out_cb&quot; が設定<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;されていない場合は、チャンネルコールバックが使用されま<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;す。2つの引数はチャンネルとメッセージです。<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="MissingTag">job-err_cb</span>&nbsp;<span class="MissingTag">err_cb</span><br>
&quot;err_cb&quot;: handler&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stderr で読み込むべきものがあるときのコールバック。チャ<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ンネルがパイプを使用している場合のみ。&quot;err_cb&quot; が設定<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;されていない場合は、チャンネルコールバックが使用されま<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;す。2つの引数はチャンネルとメッセージです。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="MissingTag">job-close_cb</span><br>
&quot;close_cb&quot;: handler&nbsp;&nbsp;&nbsp;&nbsp; チャンネルが閉じられるときのコールバック。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="MissingTag">ch_open()</span>&nbsp;の &quot;close_cb&quot; と同じです。<span class="MissingTag">close_cb</span>&nbsp;参照。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="MissingTag">job-drop</span><br>
&quot;drop&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;メッセージをいつドロップするかを指定します。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="MissingTag">ch_open()</span>&nbsp;の &quot;drop&quot; と同様(<span class="MissingTag">channel-drop</span>&nbsp;参照)。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;auto&quot; の場合、exit_cb は考慮されません。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="MissingTag">job-exit_cb</span><br>
&quot;exit_cb&quot;: handler&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ジョブが終了したときのコールバック。引数はジョブと終<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;了ステータスです。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Vim は、終了したジョブに対して最大10回/秒をチェックし<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ます。チェックは、<span class="MissingTag">job_status()</span>&nbsp;を呼び出すことによっ<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;てトリガーすることもでき、exit_cb ハンドラを呼び出すこ<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;とができます。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;データがバッファリングされ、プロセスが終了した後もコー<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ルバックが呼び出されることに注意してください。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="MissingTag">job-timeout</span><br>
&quot;timeout&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ブロッキング時にリクエストを待つ時間(例: ch_evalexpr()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;を使用するとき。ミリ秒単位。デフォルトは2000(2秒)です。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="MissingTag">out_timeout</span>&nbsp;<span class="MissingTag">err_timeout</span><br>
&quot;out_timeout&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stdout のタイムアウト。パイプ使用時のみ。<br>
&quot;err_timeout&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stderr のタイムアウト。パイプ使用時のみ。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="Todo">Note</span>: &quot;timeout&quot; を設定すると、パーツ固有のモードが上書<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;きされます。したがって、最初に &quot;timeout&quot; を設定し、後<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;でパーツ固有のモードを設定します。<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="MissingTag">job-stoponexit</span><br>
&quot;stoponexit&quot;:&nbsp;<span class="Special">{signal}</span>&nbsp;&nbsp;Vim が終了すると&nbsp;<span class="Special">{signal}</span>&nbsp;をジョブに送ります。可能な値<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;については、<span class="MissingTag">job_stop()</span>&nbsp;参照。<br>
&quot;stoponexit&quot;: &quot;&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Vim が終了してもジョブを停止しません。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;デフォルトは &quot;term&quot; です。<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="MissingTag">job-term</span><br>
&quot;term&quot;:&quot;open&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ターミナルを起動し、ジョブ stdin/stdout/stderr を接続<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;します。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="Todo">NOTE</span>: まだ実装されていません!<br>
<br>
&quot;channel&quot;:&nbsp;<span class="Special">{channel}</span>&nbsp;&nbsp;&nbsp;&nbsp;新しいチャンネルを作成する代わりに、既存のチャンネルを<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用します。新しいジョブに使用されるチャンネルの部分<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;は、以前使用された部分から切り離されます。チャンネル<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;が別のジョブで引き続き使用されていた場合、I/O エラーが<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;発生する可能性があります。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;既存のコールバックやその他の設定が残っています。<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="MissingTag">job-in_io</span>&nbsp;<span class="MissingTag">in_top</span>&nbsp;<span class="MissingTag">in_bot</span>&nbsp;<span class="MissingTag">in_name</span>&nbsp;<span class="MissingTag">in_buf</span><br>
&quot;in_io&quot;: &quot;null&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stdin を切断する(/dev/null から読み込む)<br>
&quot;in_io&quot;: &quot;pipe&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 標準入力がチャンネルに接続されている(デフォルト)<br>
&quot;in_io&quot;: &quot;file&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stdin はファイルから読み込む<br>
&quot;in_io&quot;: &quot;buffer&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stdin はバッファから読み込む<br>
&quot;in_top&quot;: number&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;buffer&quot; を使用する場合: 送信する最初の行(デフォルト:1)<br>
&quot;in_bot&quot;: number&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;buffer&quot; を使用する場合: 送信する最後の行(デフォルト:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最後)<br>
&quot;in_name&quot;: &quot;/path/file&quot; 読み込むファイルまたはバッファの名前<br>
&quot;in_buf&quot;: number&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;読み込むバッファの番号<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="MissingTag">job-out_io</span>&nbsp;<span class="MissingTag">out_name</span>&nbsp;<span class="MissingTag">out_buf</span><br>
&quot;out_io&quot;: &quot;null&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stdout を切断する(/dev/nullに行く)<br>
&quot;out_io&quot;: &quot;pipe&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stdout がチャンネルに接続されている(デフォルト)<br>
&quot;out_io&quot;: &quot;file&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stdout がファイルに書き込む<br>
&quot;out_io&quot;: &quot;buffer&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stdout はバッファに追加する(下記参照)<br>
&quot;out_name&quot;: &quot;/path/file&quot; 書き込むファイルまたはバッファの名前<br>
&quot;out_buf&quot;: number&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 書き込むバッファの番号<br>
&quot;out_modifiable&quot;: 0&nbsp;&nbsp;&nbsp;&nbsp; バッファに書き込むときに、<span class="MissingTag">'modifiable'</span>&nbsp;はオフになる<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(下記参照)<br>
&quot;out_msg&quot;: 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;新しいバッファに書き込むとき、最初の行は &quot;Reading from<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;channel output...&quot; に設定される<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="MissingTag">job-err_io</span>&nbsp;<span class="MissingTag">err_name</span>&nbsp;<span class="MissingTag">err_buf</span><br>
&quot;err_io&quot;: &quot;out&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stderr のメッセージは stdout に行く<br>
&quot;err_io&quot;: &quot;null&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stderr を切断する(/dev/nullに行く)<br>
&quot;err_io&quot;: &quot;pipe&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stderr がチャンネルに接続されている(デフォルト)<br>
&quot;err_io&quot;: &quot;file&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stderr はファイルに書き込む<br>
&quot;err_io&quot;: &quot;buffer&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stderr はバッファに追加する(下記参照)<br>
&quot;err_name&quot;: &quot;/path/file&quot; 書き込むファイルまたはバッファの名前<br>
&quot;err_buf&quot;: number&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 書き込むバッファの番号<br>
&quot;err_modifiable&quot;: 0&nbsp;&nbsp;&nbsp;&nbsp; バッファに書き込むときに、<span class="MissingTag">'modifiable'</span>&nbsp;はオフになる<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(下記参照)<br>
&quot;err_msg&quot;: 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;新しいバッファに書き込むとき、最初の行は &quot;Reading from<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;channel error...&quot; に設定される<br>
<br>
&quot;block_write&quot;: number&nbsp;&nbsp; テストのためにのみ: stdin への他のすべての書き込みをブ<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ロックするふりをする<br>
<br>
<br>
<span class="PreProc">バッファへの書き込み</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="MissingTag">out_io-buffer</span><br>
out_io または err_io モードが &quot;buffer&quot; で、コールバックがある場合、コールバッ<br>
クを呼び出す前にテキストがバッファに追加されます。<br>
<br>
入力と出力の両方にバッファが使用されている場合、最後の行はチャンネル入力に書き<br>
込まれたものなので、出力行は最後の行の上に置かれます。それ以外の場合は最後の行<br>
の下に行が追加されます。<br>
<br>
&quot;buffer&quot; を指定して JS または JSON モードを使用すると、デコード+エンコーディン<br>
グ後に、ゼロまたは負の ID を持つメッセージのみがバッファに追加されます。正の数<br>
を持つメッセージはコールバックによって処理され、コマンドは通常通り処理されま<br>
す。<br>
<br>
&quot;out_name&quot; または &quot;err_name&quot; のバッファ名は、現在のディレクトリの名前を拡張し<br>
た後も、既存のバッファの完全名と比較されます。たとえば、&quot;:edit somename&quot; でバッ<br>
ファが作成され、バッファ名が &quot;somename&quot; の場合、そのバッファが使用されます。<br>
<br>
一致するバッファがない場合、新しいバッファが作成されます。新しいバッファを常に<br>
作成するには、空の名前を使用します。<span class="MissingTag">ch_getbufnr()</span>&nbsp;を使用してバッファ番号を<br>
取得できます。<br>
<br>
新しいバッファの場合、<span class="MissingTag">'buftype'</span>&nbsp;は &quot;nofile&quot; に設定され、<span class="MissingTag">'bufhidden'</span>&nbsp;は &quot;hide&quot;<br>
に設定されます。他の設定が必要な場合は、まずバッファを作成し、バッファ番号を渡<br>
します。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="MissingTag">out_modifiable</span>&nbsp;<span class="MissingTag">err_modifiable</span><br>
&quot;out_modifiable&quot; と &quot;err_modifiable&quot; オプションは、<span class="MissingTag">'modifiable'</span>&nbsp;オプションをオ<br>
フにするか、<span class="MissingTag">'modifiable'</span>&nbsp;になっているバッファに書き込むために使用できます。つ<br>
まり、行がバッファに追加されますが、ユーザーはバッファを簡単に変更できません。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="MissingTag">out_msg</span>&nbsp;<span class="MissingTag">err_msg</span><br>
&quot;out_msg&quot; オプションは、新しいバッファが最初の行を &quot;Reading from channel<br>
output...&quot; に設定するかどうかを指定するために使用できます。デフォルトではメッ<br>
セージを追加します。&quot;err_msg&quot; はチャンネルエラーでも同じです。<br>
<br>
<span class="MissingTag">'modifiable'</span>&nbsp;オプションをオフにしたり、<span class="MissingTag">'modifiable'</span>&nbsp;オフなバッファを書き込んだ<br>
りすることができます。つまり、行がバッファに追加されますが、ユーザーはバッファ<br>
を簡単に変更できません。<br>
<br>
既存のバッファに&nbsp;<span class="MissingTag">'modifiable'</span>&nbsp;が指定されておらず、&quot;out_modifiable&quot; または<br>
&quot;err_modifiable&quot; オプションがゼロでない場合、エラーが発生し、バッファに書き込<br>
まれません。<br>
<br>
書き込まれたバッファがウィンドウに表示され、カーソルが最後の行の最初の列にある<br>
場合、カーソルは新しく追加された行に移動され、ウィンドウは必要に応じてカーソル<br>
を表示するために上にスクロールされます。<br>
<br>
追加されたすべての行に対して、取り消しが同期されます。NUL バイトは受け入れら<br>
れます(内部では Vim はこれらを NL バイトとして格納します)。<br>
<br>
<br>
<span class="PreProc">ファイルへの書き込み</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="MissingTag">E920</span><br>
ファイルはアクセス許可600(ユーザーに対しては読み書き可能、他のユーザーはアクセ<br>
ス不可)で作成されます。これを変更するには、<span class="MissingTag">setfperm()</span>&nbsp;を使用してください。<br>
<br>
ファイルがすでに存在する場合は切り捨てられます。<br>
<br>
<span class="PreProc">==============================================================================</span><br>
11. ジョブを制御する&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="MissingTag">job-control</span><br>
<br>
ジョブの状態を取得するには:<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo job_status(job)</div>
<br>
ジョブの実行を停止するには:<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;job_stop(job)</div>
<br>
これはジョブを終了させる通常の方法です。Unix では、ジョブに SIGTERM を送信し<br>
ます。他の方法でジョブを停止したり、任意の信号を送信したりすることもできます。<br>
例えば、ジョブを強制的に停止させるには、&quot;kill it&quot;:<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;job_stop(job, &quot;kill&quot;)</div>
<br>
他のオプションについては、<span class="MissingTag">job_stop()</span>&nbsp;参照。<br>
<br>
<br>
&nbsp;vim:tw=78:ts=8:ft=help:norl:<br>
</div>
